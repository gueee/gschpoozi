#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════════
# Touch Panel Setup Script - Generated by gschpoozi
# ═══════════════════════════════════════════════════════════════════════════════
#
# Display: {{DISPLAY_NAME}}
# Model: {{DISPLAY_MODEL}}
# Connection: {{CONNECTION_TYPE}}
# Rotation: {{ROTATION}}°
# Generated: {{GENERATION_DATE}}
#
# Run with: sudo bash touch-panel-setup.sh
# ═══════════════════════════════════════════════════════════════════════════════

set -e

# Configuration (populated by generator)
DISPLAY_MODEL="{{DISPLAY_MODEL}}"
DISPLAY_NAME="{{DISPLAY_NAME}}"
CONNECTION_TYPE="{{CONNECTION_TYPE}}"
ROTATION="{{ROTATION}}"
DRIVER_REQUIRED="{{DRIVER_REQUIRED}}"
DRIVER_REPO="{{DRIVER_REPO}}"
DRIVER_SCRIPT="{{DRIVER_SCRIPT}}"
OVERLAY_FIX="{{OVERLAY_FIX}}"
OVERLAY_NAME="{{OVERLAY_NAME}}"
TOUCH_DEVICE_NAME="{{TOUCH_DEVICE_NAME}}"
I2C_REQUIRED="{{I2C_REQUIRED}}"
HDMI_CONFIG="{{HDMI_CONFIG}}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# ═══════════════════════════════════════════════════════════════════════════════
# HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

log_info() {
    echo -e "${CYAN}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# PLATFORM DETECTION
# ═══════════════════════════════════════════════════════════════════════════════

detect_platform() {
    log_info "Detecting platform..."
    
    PLATFORM_TYPE="unknown"
    CONFIG_TXT_PATH=""
    OS_VERSION=""
    
    # Check for Raspberry Pi
    if [[ -f /proc/device-tree/model ]]; then
        local model_string
        model_string=$(cat /proc/device-tree/model 2>/dev/null | tr -d '\0')
        
        if [[ "$model_string" == *"Raspberry Pi"* ]]; then
            PLATFORM_TYPE="raspberry_pi"
            log_info "Detected: $model_string"
        elif [[ "$model_string" == *"CB1"* ]] || [[ "$model_string" == *"Manta"* ]]; then
            PLATFORM_TYPE="cb1"
            log_info "Detected: BTT CB1"
        fi
    fi
    
    # Check for Armbian (CB1 uses Armbian)
    if [[ "$PLATFORM_TYPE" == "unknown" ]] && [[ -f /etc/armbian-release ]]; then
        PLATFORM_TYPE="armbian"
        if grep -q "BOARD=cb1" /etc/armbian-release 2>/dev/null; then
            PLATFORM_TYPE="cb1"
            log_info "Detected: BTT CB1 (Armbian)"
        else
            log_info "Detected: Armbian SBC"
        fi
    fi
    
    # Detect OS version
    if [[ -f /etc/os-release ]]; then
        # shellcheck source=/dev/null
        source /etc/os-release
        OS_VERSION="${VERSION_CODENAME:-unknown}"
        log_info "OS: $PRETTY_NAME ($OS_VERSION)"
    fi
    
    # Determine config.txt path
    if [[ "$PLATFORM_TYPE" == "raspberry_pi" ]]; then
        if [[ "$OS_VERSION" == "bookworm" ]]; then
            CONFIG_TXT_PATH="/boot/firmware/config.txt"
        else
            CONFIG_TXT_PATH="/boot/config.txt"
        fi
    elif [[ "$PLATFORM_TYPE" == "cb1" ]]; then
        CONFIG_TXT_PATH="/boot/armbianEnv.txt"
    else
        # Try to find config.txt
        if [[ -f /boot/firmware/config.txt ]]; then
            CONFIG_TXT_PATH="/boot/firmware/config.txt"
        elif [[ -f /boot/config.txt ]]; then
            CONFIG_TXT_PATH="/boot/config.txt"
        fi
    fi
    
    if [[ -z "$CONFIG_TXT_PATH" ]]; then
        log_warning "Could not determine config.txt location"
        CONFIG_TXT_PATH="/boot/config.txt"
    else
        log_info "Config file: $CONFIG_TXT_PATH"
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# BACKUP FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

backup_config() {
    if [[ -f "$CONFIG_TXT_PATH" ]]; then
        local backup_path="${CONFIG_TXT_PATH}.backup.$(date +%Y%m%d_%H%M%S)"
        log_info "Backing up $CONFIG_TXT_PATH to $backup_path"
        cp "$CONFIG_TXT_PATH" "$backup_path"
        log_success "Backup created"
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# OVERLAY CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

apply_overlay_fix() {
    if [[ -z "$OVERLAY_FIX" ]] || [[ "$OVERLAY_FIX" == "null" ]]; then
        log_info "No overlay fix required for this display"
        return 0
    fi
    
    log_info "Applying overlay fix: $OVERLAY_FIX"
    
    if [[ ! -f "$CONFIG_TXT_PATH" ]]; then
        log_error "Config file not found: $CONFIG_TXT_PATH"
        return 1
    fi
    
    # Check if we need to replace vc4-kms-v3d with vc4-fkms-v3d
    if [[ "$OVERLAY_FIX" == "vc4-fkms-v3d" ]]; then
        if grep -q "dtoverlay=vc4-kms-v3d" "$CONFIG_TXT_PATH"; then
            log_info "Replacing vc4-kms-v3d with vc4-fkms-v3d"
            sed -i 's/dtoverlay=vc4-kms-v3d/dtoverlay=vc4-fkms-v3d/g' "$CONFIG_TXT_PATH"
            log_success "Overlay fix applied"
        elif grep -q "dtoverlay=vc4-fkms-v3d" "$CONFIG_TXT_PATH"; then
            log_info "vc4-fkms-v3d already configured"
        else
            log_info "Adding dtoverlay=vc4-fkms-v3d"
            echo "dtoverlay=vc4-fkms-v3d" >> "$CONFIG_TXT_PATH"
            log_success "Overlay added"
        fi
    fi
}

apply_display_overlay() {
    if [[ -z "$OVERLAY_NAME" ]] || [[ "$OVERLAY_NAME" == "null" ]]; then
        return 0
    fi
    
    log_info "Adding display overlay: $OVERLAY_NAME"
    
    # Check if overlay already exists
    if grep -q "dtoverlay=$OVERLAY_NAME" "$CONFIG_TXT_PATH" 2>/dev/null; then
        log_info "Overlay $OVERLAY_NAME already configured"
        return 0
    fi
    
    # Add rotation parameter if specified
    local overlay_line="dtoverlay=$OVERLAY_NAME"
    if [[ "$ROTATION" != "0" ]] && [[ -n "$ROTATION" ]]; then
        # Some overlays use r90, r180, r270 for rotation
        overlay_line="dtoverlay=${OVERLAY_NAME},r${ROTATION}"
    fi
    
    echo "$overlay_line" >> "$CONFIG_TXT_PATH"
    log_success "Display overlay added: $overlay_line"
}

enable_i2c() {
    if [[ "$I2C_REQUIRED" != "true" ]]; then
        return 0
    fi
    
    log_info "Enabling I2C..."
    
    if grep -q "^dtparam=i2c_arm=on" "$CONFIG_TXT_PATH" 2>/dev/null; then
        log_info "I2C already enabled"
        return 0
    fi
    
    # Check if commented out
    if grep -q "^#dtparam=i2c_arm=on" "$CONFIG_TXT_PATH" 2>/dev/null; then
        sed -i 's/^#dtparam=i2c_arm=on/dtparam=i2c_arm=on/' "$CONFIG_TXT_PATH"
    else
        echo "dtparam=i2c_arm=on" >> "$CONFIG_TXT_PATH"
    fi
    
    log_success "I2C enabled"
}

configure_hdmi() {
    if [[ -z "$HDMI_CONFIG" ]] || [[ "$HDMI_CONFIG" == "null" ]]; then
        return 0
    fi
    
    log_info "Configuring HDMI settings..."
    
    # Parse and apply HDMI configuration
    # Expected format: "hdmi_group=2,hdmi_mode=87,hdmi_cvt=800 480 60 6 0 0 0"
    IFS=',' read -ra HDMI_PARAMS <<< "$HDMI_CONFIG"
    for param in "${HDMI_PARAMS[@]}"; do
        local key="${param%%=*}"
        local value="${param#*=}"
        
        if grep -q "^${key}=" "$CONFIG_TXT_PATH" 2>/dev/null; then
            sed -i "s/^${key}=.*/${key}=${value}/" "$CONFIG_TXT_PATH"
        else
            echo "${key}=${value}" >> "$CONFIG_TXT_PATH"
        fi
        log_info "Set $key=$value"
    done
    
    log_success "HDMI configured"
}

configure_rotation() {
    if [[ "$ROTATION" == "0" ]] || [[ -z "$ROTATION" ]]; then
        return 0
    fi
    
    log_info "Configuring display rotation: ${ROTATION}°"
    
    case "$CONNECTION_TYPE" in
        hdmi)
            # HDMI rotation via display_hdmi_rotate
            local rotate_value
            case "$ROTATION" in
                90)  rotate_value=1 ;;
                180) rotate_value=2 ;;
                270) rotate_value=3 ;;
                *)   rotate_value=0 ;;
            esac
            
            if grep -q "^display_hdmi_rotate=" "$CONFIG_TXT_PATH" 2>/dev/null; then
                sed -i "s/^display_hdmi_rotate=.*/display_hdmi_rotate=$rotate_value/" "$CONFIG_TXT_PATH"
            else
                echo "display_hdmi_rotate=$rotate_value" >> "$CONFIG_TXT_PATH"
            fi
            ;;
        dsi)
            # DSI rotation via display_lcd_rotate or lcd_rotate
            if grep -q "^display_lcd_rotate=" "$CONFIG_TXT_PATH" 2>/dev/null; then
                sed -i "s/^display_lcd_rotate=.*/display_lcd_rotate=$ROTATION/" "$CONFIG_TXT_PATH"
            else
                echo "display_lcd_rotate=$ROTATION" >> "$CONFIG_TXT_PATH"
            fi
            ;;
    esac
    
    log_success "Display rotation configured"
}

# ═══════════════════════════════════════════════════════════════════════════════
# DRIVER INSTALLATION
# ═══════════════════════════════════════════════════════════════════════════════

install_drivers() {
    if [[ "$DRIVER_REQUIRED" != "true" ]]; then
        log_info "No additional drivers required for this display"
        return 0
    fi
    
    if [[ -z "$DRIVER_REPO" ]] || [[ "$DRIVER_REPO" == "null" ]]; then
        log_warning "Driver required but no repository specified"
        return 0
    fi
    
    echo ""
    log_warning "This display requires manufacturer drivers"
    log_info "Driver repository: $DRIVER_REPO"
    echo ""
    read -rp "Install drivers now? (y/N): " install_choice
    
    if [[ "${install_choice,,}" != "y" ]]; then
        log_info "Skipping driver installation"
        echo ""
        echo "To install drivers manually later:"
        echo "  git clone $DRIVER_REPO"
        echo "  cd $(basename "$DRIVER_REPO" .git)"
        if [[ -n "$DRIVER_SCRIPT" ]] && [[ "$DRIVER_SCRIPT" != "null" ]]; then
            echo "  sudo bash $DRIVER_SCRIPT"
        fi
        echo ""
        return 0
    fi
    
    log_info "Installing drivers..."
    
    local driver_dir="/tmp/touch-driver-install"
    rm -rf "$driver_dir"
    
    if ! git clone "$DRIVER_REPO" "$driver_dir"; then
        log_error "Failed to clone driver repository"
        return 1
    fi
    
    cd "$driver_dir"
    
    if [[ -n "$DRIVER_SCRIPT" ]] && [[ "$DRIVER_SCRIPT" != "null" ]]; then
        if [[ -f "$DRIVER_SCRIPT" ]]; then
            chmod +x "$DRIVER_SCRIPT"
            log_info "Running $DRIVER_SCRIPT"
            bash "$DRIVER_SCRIPT"
        else
            log_warning "Driver script not found: $DRIVER_SCRIPT"
        fi
    fi
    
    cd - > /dev/null
    rm -rf "$driver_dir"
    
    log_success "Drivers installed"
}

# ═══════════════════════════════════════════════════════════════════════════════
# TOUCH CALIBRATION
# ═══════════════════════════════════════════════════════════════════════════════

setup_touch_calibration() {
    if [[ -z "$TOUCH_DEVICE_NAME" ]] || [[ "$TOUCH_DEVICE_NAME" == "null" ]]; then
        log_info "Touch device name not specified, skipping calibration setup"
        return 0
    fi
    
    log_info "Setting up touch calibration for: $TOUCH_DEVICE_NAME"
    
    # Calculate transformation matrix based on rotation
    local matrix
    case "$ROTATION" in
        0)   matrix="1 0 0 0 1 0 0 0 1" ;;
        90)  matrix="0 -1 1 1 0 0 0 0 1" ;;
        180) matrix="-1 0 1 0 -1 1 0 0 1" ;;
        270) matrix="0 1 0 -1 0 1 0 0 1" ;;
        *)   matrix="1 0 0 0 1 0 0 0 1" ;;
    esac
    
    # Create udev rule for persistent calibration
    local udev_rule_path="/etc/udev/rules.d/51-touchscreen.rules"
    local udev_rule="ACTION==\"add\", ATTRS{name}==\"$TOUCH_DEVICE_NAME\", ENV{LIBINPUT_CALIBRATION_MATRIX}=\"$matrix\""
    
    log_info "Creating udev rule: $udev_rule_path"
    
    # Check if rule already exists for this device
    if [[ -f "$udev_rule_path" ]] && grep -q "$TOUCH_DEVICE_NAME" "$udev_rule_path"; then
        log_info "Updating existing calibration rule"
        # Remove old rule for this device
        sed -i "/$TOUCH_DEVICE_NAME/d" "$udev_rule_path"
    fi
    
    echo "$udev_rule" >> "$udev_rule_path"
    
    log_success "Touch calibration configured"
    log_info "Calibration matrix: $matrix (for ${ROTATION}° rotation)"
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN EXECUTION
# ═══════════════════════════════════════════════════════════════════════════════

main() {
    echo ""
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "  Touch Panel Setup - $DISPLAY_NAME"
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo ""
    
    check_root
    detect_platform
    
    echo ""
    log_info "Configuration:"
    log_info "  Display: $DISPLAY_NAME"
    log_info "  Connection: $CONNECTION_TYPE"
    log_info "  Rotation: ${ROTATION}°"
    log_info "  Driver required: $DRIVER_REQUIRED"
    echo ""
    
    read -rp "Continue with setup? (Y/n): " confirm
    if [[ "${confirm,,}" == "n" ]]; then
        log_info "Setup cancelled"
        exit 0
    fi
    
    echo ""
    
    # Execute setup steps
    backup_config
    enable_i2c
    apply_overlay_fix
    apply_display_overlay
    configure_hdmi
    configure_rotation
    install_drivers
    setup_touch_calibration
    
    echo ""
    echo "═══════════════════════════════════════════════════════════════════════════════"
    log_success "Touch panel setup complete!"
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo ""
    log_warning "A reboot is required for changes to take effect."
    echo ""
    read -rp "Reboot now? (y/N): " reboot_choice
    
    if [[ "${reboot_choice,,}" == "y" ]]; then
        log_info "Rebooting in 3 seconds..."
        sleep 3
        reboot
    else
        log_info "Please reboot manually when ready: sudo reboot"
    fi
}

main "$@"

